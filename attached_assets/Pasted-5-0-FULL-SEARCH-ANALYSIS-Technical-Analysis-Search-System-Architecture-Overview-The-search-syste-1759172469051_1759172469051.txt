5.0 FULL  SEARCH ANALYSIS:

Technical Analysis: Search System Architecture
Overview
The search system implements a resilient, asynchronous job queue architecture designed for bulk B2B lead generation. It operates in three distinct phases: Company Discovery → Contact Discovery → Email Enrichment.
Core Architecture Components
1. Job Queue System (PostgreSQL-backed)
* Database Table: search_jobs stores all search requests persistently
* Job States: pending → processing → completed/failed
* Resilience: Survives server restarts, supports 3 retry attempts
* Priority System: Jobs processed by priority (0-10 scale)
2. Background Job Processor
* Polling Frequency: Every 5 seconds
* Concurrency Control: Single-job processing to prevent race conditions
* Location: server/search/services/job-processor.ts
* Method: processNextJob() picks highest priority pending job
Search Execution Flow
Phase 1: Company Search (7-10 seconds)
// server/search/services/search-job-service.ts
executeJob() → searchCompanies(query)

* Uses Perplexity API to find matching companies
* Saves companies to PostgreSQL with deduplication
* Returns 5-10 companies per search
Phase 2: Contact Discovery (20-30 seconds)
ContactSearchService.searchContacts() → findKeyDecisionMakers()

* Batch Processing: 3 companies processed in parallel
* Multi-tier Contact Search:
    * Core Leadership (CEO, CFO, COO)
    * Department Heads (VP Sales, VP Marketing)
    * Middle Management (CTO, Technical Directors)
    * Custom Targets (user-specified roles)
* Smart Fallback Manager: Stops searching when sufficient contacts found
* Deduplication: Filters existing contacts to avoid duplicates
Phase 3: Email Enrichment Waterfall
enrichContactsWithEmails() → runEmailWaterfall()

* Contact Selection: Top 3 contacts per company (by probability score)
* Waterfall Pattern:Tier 1 & 2 (Parallel): - Apollo: Searches contacts #1 and #2 - Perplexity: Searches contacts #1 and #3  Tier 3 (Fallback): - Hunter: Searches contacts #1 and #2 (if no emails found)  
* Early Exit: Stops if emails found in parallel tier
Bulk Search Mechanisms
1. Frontend-Initiated Bulk Search
// Client triggers from PromptEditor component
POST /api/search-jobs
{
query: "SaaS companies in Austin",
searchType: "emails", // or "companies", "contacts"
contactSearchConfig: {
enableCoreLeadership: true,
enableDepartmentHeads: false
},
executeImmediately: false // Queue for async processing
}

2. Contact-Only Bulk Enrichment
// "Find Key Emails" button
POST /api/search-jobs/contacts
{
companyIds: [1, 2, 3], // Existing company IDs
metadata: {
emailSearchRequest: true,
enrichEmails: true
}
}

* Loads existing contacts from database
* Skips contact discovery, goes straight to email enrichment
3. Programmatic Bulk Searches
* Cron Jobs: Schedule daily/hourly bulk searches
* Webhooks: Trigger searches from external events
* API Integration: External systems can queue bulk jobs
Key Backend Functions
SearchJobService (search-job-service.ts)
* createJob(): Creates persistent job in database
* executeJob(): Orchestrates entire search pipeline
* executeContactOnlySearch(): Handles email-only enrichment
* enrichContactsWithEmails(): Manages email waterfall
* getPendingJobs(): Returns jobs for processor
ContactSearchService (contact-search-service.ts)
* searchContacts(): Main contact discovery orchestrator
* processBatch(): Parallel batch processing (3 companies at once)
* Handles deduplication, filtering, saving to database
Email Provider Functions
* searchApolloDirect(): Apollo API integration
* searchContactDetails(): Perplexity contact enrichment
* searchHunterDirect(): Hunter.io fallback
Performance Characteristics
* Company Search: ~7 seconds (5-10 companies)
* Contact Discovery: ~30 seconds (50-150 contacts)
* Email Enrichment: ~10-20 seconds (depends on providers)
* Total Full Search: ~60 seconds for complete pipeline
* Batch Processing: 3 companies in parallel for 3x speedup
* Database Operations: Optimized with bulk inserts/updates
Credit System Integration
* Deduction Points:
    * Company search: 10 credits
    * Contact search: 60 credits
    * Email search: 160 credits
* Transaction Logging: Every search logged with credit deductions
* Balance Check: Blocks searches if insufficient credits
Error Handling & Resilience
1. Automatic Retries: 3 attempts with exponential backoff
2. Partial Success: Continues even if some companies fail
3. Progress Tracking: Real-time updates stored in database
4. Transaction Safety: Credits only deducted on success
5. Rate Limiting: 50ms delays between API calls
This architecture ensures reliable, scalable bulk searches that can process hundreds of companies asynchronously while maintaining data integrity and providing real-time progress updates.


