Complete Email Search Technical Flow with Exact Line Numbers
Here's the precise technical sequence showing exactly how the email search flows from beginning to end:
Phase 1: Frontend User Trigger
File: client/src/pages/home.tsx
Line 2501-2523: User clicks "Find Key Emails" button
<Button
onClick={() => {
try {
if (isFromLandingPage && setIsFromLandingPage) {
setIsFromLandingPage(false);
}
} catch (e) {
// Silent fail - prevents error from showing to users
}
runConsolidatedEmailSearch(); // <-- TRIGGERS EMAIL SEARCH
}}
disabled={isConsolidatedSearching}
>
<span>{isConsolidatedSearching ? "Searching..." : "Find Key Emails"}</span>
</Button>

Phase 2: Frontend Search Function Execution
File: client/src/pages/home.tsx
Line 2017: runConsolidatedEmailSearch function starts
const runConsolidatedEmailSearch = async () => {

Line 2018-2022: Initial validation and state setup
if (!currentResults || currentResults.length === 0) return;

setIsConsolidatedSearching(true);
isAutomatedSearchRef.current = true;
setSummaryVisible(false);

Line 2027-2041: Progress state initialization
setProgressState({
currentPhase: 0,
startTime: Date.now(),
backendCompleted: false
});

setSearchProgress({
phase: progressQueue[0].name,
completed: 1,
total: progressQueue.length
});

startProgressTimer();

Line 2044-2050: Company filtering logic
const updatedResults = await refreshContactDataIfNeeded(currentResults);

const companiesNeedingEmails = updatedResults.filter(company =>
!getTopContacts(company, 3).some(contact => contact.email && contact.email.length > 5)
);

Line 2052-2057: Early exit if no companies need emails
if (companiesNeedingEmails.length === 0) {
console.log('No companies need email searches - all companies have sufficient emails');
setIsConsolidatedSearching(false);
setSummaryVisible(true);
return;
}

Line 2059-2067: Prepare company IDs and session tracking
const companyIds = companiesNeedingEmails.map(company => company.id);

console.log(`Starting backend email orchestration for ${companyIds.length} companies`);

if (currentSessionId) {
SearchSessionManager.markEmailSearchStarted(currentSessionId);
}

Phase 3: Backend API Call
File: client/src/pages/home.tsx
Line 2071-2076: Critical API call to backend
const response = await apiRequest("POST", "/api/companies/find-all-emails", {
companyIds,
searchConfig: {},
sessionId: currentSessionId
});

Phase 4: Backend Email Orchestration Engine
File: server/routes.ts
Line 2602: Backend endpoint receives request
app.post("/api/companies/find-all-emails", async (req, res) => {

Line 2603-2610: Extract and validate request data
try {
const userId = getUserId(req);
const { companyIds, sessionId } = req.body;

if (!companyIds || !Array.isArray(companyIds) || companyIds.length === 0) {
res.status(400).json({ message: "companyIds array is required" });
return;
}

Line 2614-2622: Session tracking setup
if (sessionId) {
const session = global.searchSessions?.get(sessionId);
if (session) {
session.emailSearchStatus = 'running';
global.searchSessions.set(sessionId, session);
console.log(`[Email Search] Session ${sessionId} marked as email search running`);
}
}

Line 2632-2641: Individual company processing function starts
const processCompany = async (companyId: number, index: number) => {
// Add staggered delay before starting each company
await delay(index * 400);

try {
const company = await storage.getCompany(companyId, userId);
if (!company) {
console.log(`Company ${companyId} not found, skipping`);
return { processed: 0, emailsFound: 0, result: null };
}

Line 2645-2653: Contact filtering for each company
const contacts = await storage.listContactsByCompany(company.id, userId);

const topContacts = contacts
.sort((a, b) => (b.probability || 0) - (a.probability || 0))
.slice(0, 3)
.filter(contact => !contact.email || contact.email.length <= 5);

Phase 5: Multi-Tier Search Strategy Execution
File: server/routes.ts
Line 2660-2688: Apollo API search function
const searchApolloContacts = async (contacts: Contact[]) => {
let emailsFound = 0;
let contactsProcessed = 0;
const sources = [];

for (const contact of contacts) {
try {
const apolloResponse = await fetch(`http://localhost:5000/api/contacts/${contact.id}/apollo`, {
method: 'POST',
headers: { 'Content-Type': 'application/json', 'Authorization': req.headers.authorization || '' }
});

const apolloData = await apolloResponse.json();
if (apolloResponse.status === 200 || apolloResponse.status === 422) {
const contactData = apolloResponse.status === 200 ? apolloData : apolloData.contact;
if (contactData.email && contactData.email.length > 5) {
emailsFound++;
sources.push(`Apollo-${contact.name}`);
console.log(`Apollo found email for ${contact.name}: ${contactData.email}`);
}
contactsProcessed++;
}
} catch (error) {
console.error(`Apollo search failed for contact ${contact.id}:`, error);
contactsProcessed++;
}
}

return { emailsFound, contactsProcessed, sources };
};

Line 2692-2717: Perplexity AI search function
const searchPerplexityContacts = async (contacts: Contact[]) => {
let emailsFound = 0;
let contactsProcessed = 0;
const sources = [];

for (const contact of contacts) {
try {
const enrichedDetails = await searchContactDetails(contact.name, company.name);
if (enrichedDetails && enrichedDetails.email && enrichedDetails.email.length > 5) {
await storage.updateContact(contact.id, {
...enrichedDetails,
completedSearches: [...(contact.completedSearches || []), 'contact_enrichment']
}, userId);
emailsFound++;
sources.push(`Perplexity-${contact.name}`);
console.log(`Perplexity found email for ${contact.name}: ${enrichedDetails.email}`);
}
contactsProcessed++;
} catch (error) {
console.error(`Perplexity search failed for contact ${contact.id}:`, error);
contactsProcessed++;
}
}

return { emailsFound, contactsProcessed, sources };
};

Line 2751-2761: Parallel execution strategy
const contact1 = topContacts[0]; // Highest scored
const contact2 = topContacts[1]; // Second highest
const contact3 = topContacts[2]; // Third highest

console.log(`Starting parallel search - Apollo: contacts 1&2, Perplexity: contacts 1&3 for ${company.name}`);
const [apolloResults, perplexityResults] = await Promise.all([
searchApolloContacts([contact1, contact2].filter(Boolean)),
searchPerplexityContacts([contact1, contact3].filter(Boolean))
]);

Line 2768-2780: Early return if emails found
if (combinedEmailsFound > 0) {
console.log(`Parallel search success for ${company.name}: ${combinedEmailsFound} emails found`);
return {
processed: combinedContactsProcessed,
emailsFound: combinedEmailsFound,
result: {
companyId: company.id,
companyName: company.name,
emailsFound: combinedEmailsFound,
source: combinedSources.join(', ')
}
};
}

Line 2783-2784: Hunter.io fallback strategy
console.log(`No emails found in parallel search, trying Hunter for ${company.name}`);
const hunterResults = await searchHunterContacts([contact1, contact2].filter(Boolean));

Phase 6: Results Processing and Database Updates
File: server/routes.ts
Line 2803-2806: Process all companies in parallel
const companyResults = await Promise.all(
companyIds.map((companyId, index) => processCompany(companyId, index))
);

Line 2808-2825: Source breakdown calculation
const sourceBreakdown = { Perplexity: 0, Apollo: 0, Hunter: 0 };

for (const { processed, emailsFound, result } of companyResults) {
totalProcessed += processed;
totalEmailsFound += emailsFound;
if (result) {
results.push(result);
if (result.source && result.emailsFound > 0) {
const sources = result.source.split(', ');
sources.forEach(source => {
if (source.includes('Apollo')) {
sourceBreakdown.Apollo++;
} else if (source.includes('Perplexity')) {
sourceBreakdown.Perplexity++;
} else if (source.includes('Hunter')) {
sourceBreakdown.Hunter++;
}
});
}
}
}

Line 2845-2859: Return results to frontend
res.json({
success: true,
summary: {
companiesProcessed: companyIds.length,
contactsProcessed: totalProcessed,
emailsFound: totalEmailsFound,
sourceBreakdown
},
results
});

Phase 7: Frontend Results Processing
File: client/src/pages/home.tsx
Line 2078-2082: Response validation
if (!response.ok) {
throw new Error(`Backend orchestration failed: ${response.status}`);
}

const data = await response.json();

Line 2084-2096: Session completion and data storage
console.log(`Backend orchestration completed:`, data.summary);

if (currentSessionId) {
SearchSessionManager.markEmailSearchCompleted(currentSessionId);
}

setProgressState(prev => ({ ...prev, backendCompleted: true }));

setLastEmailSearchCount(data.summary.emailsFound);
setLastSourceBreakdown(data.summary.sourceBreakdown);

Line 2099-2102: Success notification
toast({
title: "Email Search Complete",
description: `Found ${data.summary.emailsFound} emails for ${data.summary.contactsProcessed} contacts across ${data.summary.companiesProcessed} companies`,
});

Phase 8: Complete Database Reload and UI Update
File: client/src/pages/home.tsx
Line 2104-2112: Clear stale data
console.log('EMAIL SEARCH COMPLETE: Starting complete database reload to ensure email persistence');

localStorage.removeItem('searchState');
sessionStorage.removeItem('searchState');
localStorage.removeItem('lastEmailSearchTimestamp');
localStorage.removeItem('emailPreservationData');
console.log('Cleared all localStorage state');

Line 2114-2119: Database reload
await new Promise(resolve => setTimeout(resolve, 1000));

console.log('Fetching complete fresh data from database...');
const freshResults = await refreshContactDataFromDatabase(currentResults);

Line 2121-2129: Verify results and update UI
const emailCount = freshResults.reduce((total, company) =>
total + (company.contacts?.filter(c => c.email && c.email.length > 0).length || 0), 0
);

console.log(`Database reload completed with ${emailCount} emails found`);

setCurrentResults(freshResults);

Line 2131-2144: Save complete state
const completeState = {
currentQuery,
currentResults: freshResults,
currentListId,
emailSearchCompleted: true,
emailSearchTimestamp: Date.now()
};

const stateString = JSON.stringify(completeState);
localStorage.setItem('searchState', stateString);
sessionStorage.setItem('searchState', stateString);

This complete flow shows exactly how the email search progresses from user click through backend processing to final UI updates, with precise line numbers for each transition point.
